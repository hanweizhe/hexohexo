title: java多线程编程核心技术----java多线程技能
author: 夏茂盛
tags:
  - java多线程编程核心技术
categories:
  - java多线程编程核心技术| java多线程技能
date: 2017-11-12 13:28:31
---
-java多线程技能
author: 夏茂盛
tags:
  - java多线程编程核心技术
categories:
  - java多线程编程核心技术| java多线程技能
date: 2017-11-12 13:28:31
---
-java多线程技能
date: 2017-11-12 13:28:31
author: 夏茂盛
tags:
  - java多线程编程核心技术
categories:
  - java多线程编程核心技术| java多线程技能
---

#### 概念

**进程**：通过查看“windows任务管理器”中的列表，完全可以将运行在内存中的exe文件理解成进程。

进程是受操作系统管理的基本运行单元。

**线程**：线程可以理解成是在进程中独立运行的子任务。比如，QQ.exe运行时就有很多的子任务在同时运行。

那么，使用多线程有什么优点呢？

单线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，任务2必须等任务1执行完10秒之后才能执行。

 特点：排队执行，即同步，CPU利用率大幅降低。
 
多线程运行环境：任务1和任务2是两个相互独立，互不关心的任务。任务1用时10秒，任务2用时1秒，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等待10秒再运行。

 特点：在使用异步，系统的运行效率得到大幅度提升。
 
多线程是异步的，所以千万不要把Eclipse里代码的顺序当成线程的执行顺序，线程被调用的时机是随机的。
 
一个进程在运行时至少有一个线程在运行，比如在Java中，调用`public static void main()`方法就会创建一个线程，名字叫main（这个main和main方法名字没有任何关系），而且它是由JVM创建的。
 
#### 使用多线程

实现多线程编程有两种主要方式：一种是继承Thread类，另一种是实现Runnable接口。都是重写`run`方法。（java支持单继承）
 
 Thread.java类也实现啦Runnable接口
 
Thread.java类中的start()方法通知“线程规划池”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。
 
thread.run()方法而是同步，此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是必须等待run()方法中的代码执行完之后才可以执行后面代码。
 
执行start()方法的顺序并不代表线程启动的顺序。
 
非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。（使用synchronized关键字加锁）
 
留意i++与System.out.println()的异常：使用`System.out.println("i="+(i++))`
虽然println()方法内部是同步的，但i++的操作却是在进入println()之前发生的，所以有发生非线程安全问题的概率。


currentThread()方法：返回代码段正在被哪个线程调用的信息。

isAlive()方法：判断当前线程是否处于活动状态。

sleep()方法：在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指`this.currentThread()`返回的线程。

getId()方法：获取线程的唯一标识。

yield()方法：放弃当前的CPU资源，将它让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。

#### 停止线程
 ``` 
 线程正常退出，即run()方法完成后线程终止。
 使用stop()方法强行终止线程。（不推荐使用）
 使用interrupt方法中断线程。（还需要加入一个判断才可以完成线程----抛出异常，break，return）
 
 ```
判断线程是否是停止状态：
 
 ```
 this.interrupted():测试当前线程是否已经是中断状态，执行后具有将状标志置清除为false的功能。当前线程是指运行this.interrupted()方法的线程。

 this.isInterrupted():测试线程Thread对象是否已经是中断状态，但不清除状态标志。
 
 ```
 
#### 暂停线程
 
使用`suspend()`方法暂停线程，使用`resume()`方法恢复线程的执行。
 
缺点：独占，不同步
 
#### 线程优先级

线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。

设置线程优先级有助于帮“线程规划器”确定在下一次选择哪个线程来优先执行。

线程优先级分为`1~10`这10个等级，如果小于1或大于10，则JDK抛出异常`throw new IllegalArgumentException()`,


JDK使用3个常量来预置定义优先级的值：

```
 public final static int MIN_PRIORITY = 1;
 public final static int NORM_PRIORITY = 5;
 public final static int MAX_PRIORITY = 10;

```
 线程优先级具有继承性：A线程启动B线程，则B线程的优先级与A一样。
 
 高优先级的线程总是`大部分`先执行完，但不代表高优先线程全部先执行完。
 
 线程的优先级与代码的执行顺序无关。
 
 
 #### 守护线程
 
 在java线程中有两种线程，一种是用户线程，另一种是守护线程。
 
 任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，当进程中不存在非守护线程了，则守护线程自动销毁。
 
 典型的守护线程是：GC（垃圾回收器）
 
 `thread.setDaemon(true)`：设置当前线程为守护线程。